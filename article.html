<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<link rel="stylesheet" href="style.css">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
<script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha384-A7FZj7v+d/sdmMqp/nOQwliLvUsJfDHW+k9Omg/a/EheAdgtzNs3hpfag6Ed950n" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script>
</head>
<body>
	<div id="article">
		<h1>Объектно ориентированное программирование/проектирование в JAVASCRIPT и PHP</h1>
		<h2>Вступление</h2>
		<h3>Немного о языках</h3>
		<h4>JavaScript</h4>
		<p>JavaScript изначально создавался для того, чтобы сделать web-странички «живыми». Программы на этом языке называются скриптами. В браузере они подключаются напрямую к HTML и, как только загружается страничка – тут же выполняются.
		Программы на JavaScript – обычный текст. Они не требуют какой-то специальной подготовки.</p>
		<h4>PHP</h4>
		<p>PHP (рекурсивный акроним словосочетания PHP: Hypertext Preprocessor) - это распространенный язык программирования общего назначения с открытым исходным кодом. PHP сконструирован специально для ведения Web-разработок и его код может внедряться непосредственно в HTML.
		PHP отличается от JavaScript тем, что PHP-скрипты выполняются на сервере и генерируют HTML, который посылается клиенту. </p>
		<h3>Основы синтаксиса</h4>
		<h4>Объявление переменных: </h4>
		<h5>JS:</h5>
		<div class="code">
var argName;
		</div>
		<h5>PHP:</h5>
		<div class="code">
$argname;
		</div>
		<p>Пример:</p>
		<h5>JS:</h5>
		<div class="code">
			<pre>
var name = "Иван"; //строка
var age = 15; //число
var birthday = [16, 9, 1996]; //массив
			</pre>
		</div>
		<h5>PHP: </h5>
		<div class="code">
			<pre>
$name = "Фёдор"; //строка
$age = 17; //число
$birthday = [08, 10, 1990]; //массив
			</pre>
		</div>
		<p>Конструкция if:</p>
		<h5>JS и PHP:</h5>
		<div class="code">
			<pre>
if (arg1 > arg2) {
	код в случае true
} else {
	код в случае false
}
			</pre>
		</div>
		<h5>Пример на JS:</h5> 
		<div class="code">
			<pre>
if (a > b) {
	a = a+1;
} else {
	b = b+1;
} //если a больше b - увеличим a, если a меньше или равно b - увеличим b;
			</pre>
		</div>
		<p>Циклы:</p> 
		<h5>while в PHP и JS:</h5> 
		<div class="code">
			<pre>
while (выражение) {
		выполняется, пока выражение = true
}
			</pre>
		</div>
		<h5>Пример на JS: </h5>
		<div class="code">
			<pre>
while (a > b) {
		a = a-1;
} //цикл сработает, если a будет больше b и будет продолжать уменьшать аргумен a, пока он не станет не меньше b;
			</pre>
		</div>
		<h5>do-while в JS и PHP:</h5>
		<div class="code">
			<pre>
do {
  код цикла
} while (выражение);
			</pre>
		</div>
		<h5>Пример на PHP:</h5>
		<div class="code">
			<pre>	
do {
 $a = $a - 1;
} while ($a > $b); //цикл уменьшит перменную a, а затем будет уменьшаеть её до тех пор, пока она станет не больше b;
			</pre>
		</div>
		<p>Отличие цикла while от do-while состоит в том, что во втором случае цикл выполнится минимум один раз и только потом проверит значение выражения.</p>
		<h5>for в JS и PHP:</h5>
		<div class="code">
			<pre>
for (переменная цикла; условие выхода; дейсвтие на каждой итерации) {
 код цикла;
}
			</pre>
		</div>
		<p>Этот цикл считается самым сложным, но в то же время наиболее часто используемым.</p>
		<p>Примеры:</p>
		<h5>JS: </h5>
		<div class="code">
			<pre>
for (var i = 0; i <5; i = i + 1) {
  alert(i);
}
			</pre>
		</div>
		<h5>PHP:</h5>
		<div class="code">
			<pre>
for ($i = 0; $i<5; $i = $i + 1) {
  echo($i);
}
			</pre>
		</div>
		<p>Оба кода по своему действию идентичны. Вначале мы задаем переменную цикла i, затем указываем, что цикл выполняется, пока i меньше 5 и далее при каждой итерации увеличиваем переменную i на единицу. Код внутри цикла будет выводить i.</p>
		<h5>Функции в JS и PHP: </h5>
		<div class="code">function имя(аргументы) {
		  код функции
		}
		</div>
		<h5>Пример создания функции в JS: </h5>
		<div class="code">
			<pre>
function sum(a,b) {
  var sum = a + b;
  return sum
} //создание функции, которая будет считать сумму аргументов a и b
			</pre>
		</div>
		<h5>Пример вызова функции в JS:</h5>
		<div class="code">
			<pre>
var a = 5;
var b = 11;
sum(a,b); //функция вернет число 16;
			</pre>
		</div>
		<h2>ООП</h2>
		<h3>Что такое объектно-ориентированное программирование?</h3>
		<p>Если вы когда-то создавали собственные функции и использовали их, то вы использовали такой стиль программирования, как процедурный. В процедурном программировании вы обычно создаете структуры данных - числа, строки, массивы и т.д. - для хранения каких-то данных, а затем обрабатываете эти структуры специальными функциями, которые манипулируют этими данными.</p>
		<p>Объектно-ориентированное программирование, или ООП, пошло вперед, так как здесь мы храним структуры данных и функции, их обрабатывающие, в одной сущности, называемой объектом. Вместо того, чтобы обработать данные какой-либо функцией, вы загружаете эти данные в объект, а затем вызываете его методы для манипулирования ими и получаете желаемый результат.</p>
		<p>Чаще всего объекты, создаваемые с помощью ООП, отражают реальные сущности. Например, если вы создаете форум для своего сайта, вам следовало бы создать объект Member, который будет хранить информацию о каждом участнике форума (имя, логин, электронный адрес, пароль и др.), а также методы, которые будут обрабатывать эту информацию (регистрация, авторизация, выход из системы, бан и т.д.).</p>
		<h3>Зачем использовать ООП?</h3>
		<p>Процедурный и объектно-ориентированный - это два разных способа сделать одно и то же. Нельзя сказать, что один из них лучше другого - каждый пишет, как ему нравится, так что вы даже можете легко комбинировать эти два подхода в одном скрипте.</p>
		<p>Однако, вот некоторые преимущества ООП для разработчиков:</p>
		<p>Легче отражать реальные ситуации: как я отметил выше, объекты отражают реальные сущности - люди, товары, карточки, статьи в блогах и др. Это во многом упрощает задачу, когда вы только начинаете проектировать свое приложение, так как назначение каждого объекта, как и цель отношений между объектами, будет ясно и понятно.</p>
		<p>Легче писать модульные программы: ООП предполагает написание модулей. Разделяя код на модули, вам будет легче им управлять, дебажить и расширять его.</p>
		<p>Легче писать код, который будет использоваться много раз: написание кода, который можно будет использовать не один раз, сэкономит время при написании приложения, и со временем вы даже можете создать целую библиотеку такого рода модулей, которые вы сможете использовать во многих приложениях. С помощью ООП становится сравнительно легче писать такой код, так как структуры данных и функции инкапсулируются в единственный объект, который можно использовать любое количество раз.</p>
		<h3>Некоторые основные понятия</h3>
		<p>Перед тем, как начать писать скрипты, необходимо хорошо разобраться с такими понятиями, как класс, объект, переменная класса и метод.</p>
		<h4>Классы</h4>
		<p>Класс - это каркас для объекта. Это кусок кода, который определяет:</p>
		<p>Типы данных, которые будут содержать созданные объекты класса</p>
		<p>Функции, которые будут содержать эти объекты.</p>
		<p>Когда вы создаете приложение на ООП, вы обычно будете создавать несколько классов, которые будут представлять различные типы сущностей вашего приложения. Например, для создания форума вы можете создать классы Forum, Topic, Post и Member.</p>
		<h4>Объекты</h4>
		<p>Объект - это переменная специального типа, которая создается через класс. Он содержит действительные данные и функции для манипулирования ими. Вы можете создавать сколько угодно объектов от одного единственного класса. Каждая функция объекта не зависит от другого объекта, даже если они созданы от одного и того же класса.</p>
		<p>Для сравнения с реальными сущностями:</p>
		<p>Класс - это каркас для автомобиля: он определяет, как автомобиль будет выглядеть и действовать, но это все же абстрактная сущность</p>
		<p>Объект - это настоящий автомобиль, созданный из каркаса: у него есть настоящие свойства (например, скорость) и поведение (например, ускорение или торможение).
		На заметку: Объект часто называют сущностью класса, а процесс создания объекта класса - реализацией.</p>
		<h4>Переменные класса</h4>
		<p>Значения данных, которые хранятся в том или ином объекте, записываются в специальные переменные, называемые переменными класса. Переменные класса тесно связаны с его объектом. Несмотря на то что все объекты класса имеют одни и те же переменные, их значения могут отличаться.</p>
		<h4>Методы</h4>
		<p>Функции, определяемые в классе и применяемые для объектов этого класса, называются методами. Они не во многом отличаются от обычных функций - вы можете передавать им значения, они могут содержать локальные переменные и возвращать значения. Однако, методы чаще работают с переменными объекта. К примеру, метод login() для авторизации пользователей в вашем форуме может устанавливать значение переменной класса loggedIn в true.</p>
		<h2>Приступим к изучению ООП в JavaScript и PHP</h2>
		<h3>Создание классов:</h3>
		<p>Синтаксис:</p>
		<h5>JS и PHP:</h5>
		<div class="code">
			<pre>
class Название {
	код
}
			</pre>
		</div>
		<p>Создадим класс User:</p>
		<h5>JS и PHP:</h5>
		<div class="code">
			<pre>
class User {
}
			</pre>
		</div>
		<p>Теперь давайте научим наш класс давать новым объектам имена. Для подобных целей создан конструктор. Конструктор - это метод, который выполняется при создании объекта. </p>
		<h5>JS:</h5>
		<div class="code">
			<pre>
class User {
	constructor(name) {
		this.name = name;
	}
}
			</pre>
		</div>
		<h5>PHP:</h5>
		<div class="code">
			<pre>
class User {
	function __construct($name) {
		$this->name = $name;
	}
}
			</pre>
		</div>
		<p>Итак, разберемся же, что мы здесь понаписывали. А в общем и целом мы создали тот самый метод-конструктор. Теперь, создавая новый объект класса User мы сможем задать ему свойство, а точнее имя нашего юзера.</p>
		<p>Так же у нас появилось новое ключевое слово this. Ключевое слово this указывает на данный объект. Сложновато? Ну например представим, что из класса user мы создали несколько объектов. И не будь у нас слова this, язык бы не знал, имя какого из объектов нам необходимо. Например, вот таким способом: this.name = name – мы говорим, что свойству name объекта, который мы создадим, будет присвоено значение, которое мы запишем при создании этого объекта. То есть мы вполне могла написать что-то вроде this.firstName = name, и это значило бы, что свойство объекта называлось бы не name, а firstName и в него записалось бы значение, которые мы вписываем в конструктор при создании. Что бы понять это мы приступим, собственно, к созданию объектов. Что бы создать объект нам необходимо ключевое слово new. </p><p>Посмотрим: </p>
		<h5>JS: </h5>
		<div class="code">
let user1 = new User('Fred');
		</div>
		<p>Ключевое слово let в данном случае аналогично var и являет собой объявление переменной с немного измененными правилами.</p>
		<h5>PHP:</h5>
		<div class="code">
$user1 = new User('Fred');
		</div>
		<p>Переменной user1 в этой строке присваивается объект, который создан из класса User. Так же благодаря конструктору мы смогли сражу же дать свойство имени этому объекту. То самое свойство name, о котором говорилось выше.
		</p>
		<p>Итак, теперь у нас есть user1, которого зовут Fred. Давайте же научим его говорить своё имя.</p>
		<h5>JS:</h5>
		<div class="code">
			<pre>
class User {
	constructor(name) {
		this.name = name;
	}
	sayHi() {
		alert(this.name);
	}
}
			</pre>
		</div>
		<h5>PHP:</h5>
		<div class="code">
			<pre>
class User {
	function __construct($name) {
		$this->name = $name;
	}
	function sayHi() {
		echo $this->name;
	}
}
			</pre>
		</div>
		<p>Как видите методы – это всё те же функции. В js они объявляются внутри класса без ключевого слова function. Примечание:  конструкцию echo и функцию alert() мы используем для того, что бы выводить на экран необходимые нам данные.</p>
		<p>Попробуем заставить его всё-таки с нами поздороваться:</p> 
		<h5>JS: </h5>
		<div class="code">
			<pre>
let user1 = new User('Fred');
user1.sayHi();
			</pre>
		</div>
		<h5>PHP:</h5>
		<div class="code">
			<pre>
$user1 = new User('Fred');
$user1->sayHi();
			</pre>
		</div>
		<p>И тебе привет, Fred. Наконец-то наш юзер поздоровался.</p>
		<p>Для доступа к свойствам и методам объекта изпользуется точка(.) в js и стрелочка(-> знак «минус» и знак «больше») в PHP.</p>
		<h2>Public, Private, Protected - модификаторы доступа для методов и свойств</h2>
		<p>Позволяют управлять доступом к методам и свойствам. Видимость свойств и методов может быть определена ключевыми словами: public, private, protected. Модификатор public позволяет обращаться к свойствам и методам отовсюду. Модификатор private позволяет обращаться к свойствам и методам только внутри текущего класса. Модификатор protected позволяет обращаться к свойствам и методам только текущего класса и класса, который наследует свойства и методы текущего класса. Если модификатор не указан – то он выставляется по умолчанию public. И всё это относиться исключительно к PHP так как по факту в JavaScript все методы относятся к public модификатору. Почему я сказал только методы? Да потому что в JS мы не можем определить внутри класса переменную/свойство. Язык не предусматривает такую возможность и полагается, что в классе должны быть только методы. В PHP же мы вполне можем себе это позволить. Например вот так: </p>
		<div class="code">
			<pre>
class User {
	public $name = "Fred";
	private $age = 14;
	protected $height = 198; //Наш Fred - баскетболист
}
			</pre>
		</div>
		<p>Так же хочу заметить, что значения этих свойств являются значениями по умолчанию. То есть если у объекта, созданного из этого класса, не будет изменены данные свойства - они останутся равными тем значениям, что мы указали.  </p>
		<h2>Геттеры, сеттеры</h2>
		<p>Метод-получатель (get) и метод-установщик (set) используются для пре-доставления универсального интерфейса при обращении к свойствам в объектах. Для того, что бы понять, что это такое давайте немного усовершенствуем наш класc.</p>
		<h5>JS:</h5>
		<div class="code">
			<pre>
class User {
	constructor(firstName,lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	} //теперь создавая объект мы будем задавать два параметра

	get fullName() {
    	alert(this.firstName + ' ' + this.lastName);
  	} //метод получаения полного имени

  	set fullName(newValue) {
    	[this.firstName, this.lastName] = newValue.split(' ');
  	} //метод для установления нового имени
}

let user1 = new User('Fred','Smith'); //создаем объект
user1.fullName; // он назовет себя Fred Smith
user1.fullName = 'Derek Berk'; //но мы дадим ему другое имя
user1.fullName; // Теперь наш новый юзер именует себя Derek Berk
			</pre>
		</div>
		<h5>PHP:</h5>
		<div class="code">
			<pre>
class User {
	function __construct($firstName, $lastName) {
		$this->firstName = $firstName;
		$this->lastName = $lastName;
	}
	function __set($name, $value) {
		$this->name = explode(" ", $value);
		$this->firstName = $this->name[0];
		$this->lastName = $this->name[1];
	}
	function __get($name) {
		$this->name = $this->firstName." ".$this->lastName;
		echo $this->name;
	}
}
$user1 = new User('Fred','Smith');
$user1->fullName = "Derek Berk";
$user1->fullName;
			</pre>
		</div>
		<p>В PHP методы __get и __set (да и вообще все методы, которые начинаются с двойного подчеркивания) называют «магические методы». Так как в PHP мы всё же можем создавать свойства внутри класса, то целевое предназначение методов __set и __get – это работа с несуществующими переменными: их созданием, редактированием и получения к ним доступа. Либо же для изменения и доступа приватных переменных.</p>
		<h2>STATIC свойства</h2>
		<p>Объявление свойств и методов класса статическими позволяет обращаться к ним без создания экземпляра класса. Атрибут класса, объявленный статическим, не может быть доступен посредством экземпляра класса (но статический метод может быть вызван).
		Делается это вот так:</p>
		<h5>JS:</h5>
		<div class="code">
			<pre>
class User {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  static createGuest() {
    return new User("Гость", "Сайта");
  }
};
let user = User.createGuest();
alert( user.firstName ); // Гость
			</pre>
		</div>
		<h5>PHP:</h5>
		<div class="code">
			<pre>
class User {
	function __construct($firstName,$lastName) {
		$this->firstName = $firstName;
		$this->lastName = $lastName;
	}
	static function createGuest() {
		return new User('Гость','Сайта');
	}
}
$user1 = User::createGuest();
echo $user1->firstName;//Гость
			</pre>
		</div>
		<p>Так же свойство Static можно использовать для создания констант в классах в JS, вот так например:</p>
		<div class="code">
			<pre>
class Menu {
	  static get elemClass() {
	    return "menu"
	  }
	}
alert( Menu.elemClass );//выведет ”menu”
			</pre>
		</div>
		<h2>Наследование</h2>
		<p>Один из постулатов ООП – это наследование. Если конкретизировать – то это значит, что мы можем создавать классы, которые будут наследовать свойства класса родителя но иметь что-то своё, собственное. Что бы было понятнее сразу же перейдем к практике. </p>
		<p>Синтаксис: </p>
		<h5>JS и PHP:</h5>
		<div class="code">class Child extends Parent {
		  ...
		}</div>
		<p>Теперь давайте же подумаем, для чего нам может быть полезно наследование. Вернемся к нашему классу Юзер. Допустим нам нужно написать новый класс – для администраторов. Если вдуматься – то администратор может всё то же, что и юзер и даже больше! Так что каждый администратор является юзером, но не каждый юзер является администратором. Отлично! Как раз то, что нам нужно. Итак, вспомним наш класс юзер – вот такой: </p>
		<h5>JS:</h5>
		<div class="code">
			<pre>		
class User {
	constructor(name) {
		this.name = name;
	}
	sayHi() {
		alert(this.name);
	}
}
			</pre>
		</div>
		<h5>PHP:</h5>
		<div class="code">
		<pre>		
class User {
	function __construct($name) {
		$this->name = $name;
	}
	function sayHi() {
		echo $this->name;
	}
}
			</pre>
		</div>
		<p>Теперь давайте создадим класс Admin, который будет заимствовать методы класса User, но так же добавлять своё.</p>
		<h5>JS:</h5>
		<div class="code">
			<pre>
class Admin extends User {
	constructor(name) {
		super(name);//наследуем конструктор от предка
		this.admin = true;//добавляем новую переменную
	}
	sayHi() {
		super.sayHi();//наследуем метод от предка
		alert('and i am Administrator');//добавляем новую строку для вывода
	}
}
			</pre>
		</div>
		<h5>PHP:</h5>
		<div class="code">
			<pre>
class Admin extends User {
	function __constructor($name) {
		parent::__constructor($name);//наследуем конструктор от предка
		$this->admin = true;//добавляем новую переменную
	}
	function sayHi() {
		parent::sayHi();// наследуем метод от предка
		echo ", and i'm Administrator";//добавляем новую строку для вывода
	}
}
			</pre>
		</div>
		<p>Создание объектов и вызов методов для наследуемых классов абсолютно аналогичен классу родителю или любому другому классу. Например посмотрим, как это будет выглядеть в PHP: </p>
		<div class="code">
			<pre>		
$admin1->new Admin(‘Ivan’);
$admin1->sayHi();<span class="comment">//выведет строку “Ivan, and i'm administrator”;</span>
			</pre>
		</div>
		<p>Польза от наследования видна на лицо. Не будь этой возможности – ООП потеряло бы половину своей полезности. Мы можем создавать целые конструкции из наследуемых классов, наследуя классы друг за другом, ветвя их и развивая наш код, и при всём при этом другой программист, который, возможно, будет дорабатывать наш код, сможет с лёгкостью разобраться во всем и не рисковать, изменяя уже написанные строки.</p>
	</div>
</body>
</html>
